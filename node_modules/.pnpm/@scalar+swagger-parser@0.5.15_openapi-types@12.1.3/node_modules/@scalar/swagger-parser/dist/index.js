import k from "@apidevtools/swagger-parser";
import I from "js-yaml";
typeof window < "u" && (window.process = window.process || {
  platform: "browser",
  browser: !0
});
const M = (t) => {
  var o, i, a, c;
  const s = ((o = t.info) == null ? void 0 : o.title) !== void 0, r = ((i = t.info) == null ? void 0 : i.description) !== void 0, n = ((a = t.tags) == null ? void 0 : a.length) ?? 0, f = t.tags.reduce(
    (p, g) => {
      var h;
      return p + (((h = g.operations) == null ? void 0 : h.length) ?? 0);
    },
    0
  ), e = Object.keys(((c = t == null ? void 0 : t.components) == null ? void 0 : c.schemas) ?? {}).length ?? 0;
  return {
    hasTitle: s,
    hasDescription: r,
    numberOfTags: n,
    numberOfOperations: f,
    numberOfModels: e
  };
}, P = [
  "GET",
  "POST",
  "PUT",
  "HEAD",
  "DELETE",
  "PATCH",
  "OPTIONS",
  "CONNECT",
  "TRACE"
], x = (t) => new Promise((s, r) => {
  try {
    const n = S(t);
    k.dereference(n, (f, e) => {
      if (f && r(f), e === void 0) {
        r("Couldnâ€™t parse the Swagger file.");
        return;
      }
      const o = j(e);
      s(o);
    });
  } catch (n) {
    r(n);
  }
}), j = (t) => {
  t.tags || (t.tags = []), t.paths || (t.paths = {});
  const s = {};
  Object.keys(t.webhooks ?? {}).forEach(
    (n) => {
      var f;
      Object.keys(
        ((f = t.webhooks) == null ? void 0 : f[n]) ?? {}
      ).forEach((e) => {
        var i, a, c;
        const o = ((i = t.webhooks) == null ? void 0 : i[n])[e];
        s[n] === void 0 && (s[n] = {}), s[n][e] = {
          // Transformed data
          httpVerb: e,
          path: n,
          operationId: (o == null ? void 0 : o.operationId) || n,
          name: (o == null ? void 0 : o.summary) || n || "",
          description: (o == null ? void 0 : o.description) || "",
          pathParameters: (c = (a = t.paths) == null ? void 0 : a[n]) == null ? void 0 : c.parameters,
          // Original webhook
          information: {
            ...o
          }
        };
      });
    }
  ), Object.keys(t.paths).forEach((n) => {
    Object.keys(t.paths[n]).filter(
      (e) => P.includes(e.toUpperCase())
    ).forEach((e) => {
      var a, c, p, g, h, w;
      const o = t.paths[n][e], i = {
        httpVerb: e,
        path: n,
        operationId: o.operationId || n,
        name: o.summary || n || "",
        description: o.description || "",
        information: {
          ...o
        },
        pathParameters: (c = (a = t.paths) == null ? void 0 : a[n]) == null ? void 0 : c.parameters
      };
      if (!o.tags || o.tags.length === 0) {
        (p = t.tags) != null && p.find(
          (d) => d.name === "default"
        ) || (g = t.tags) == null || g.push({
          name: "default",
          description: "",
          // @ts-ignore
          operations: []
        });
        const m = (h = t.tags) == null ? void 0 : h.findIndex(
          (d) => d.name === "default"
        );
        m >= 0 && ((w = t.tags[m]) == null || w.operations.push(i));
      } else
        o.tags.forEach((m) => {
          var y, b, T;
          const d = (y = t.tags) == null ? void 0 : y.findIndex(
            // @ts-ignore
            (E) => E.name === m
          );
          d === -1 && ((b = t.tags) == null || b.push({
            name: m,
            description: ""
          }));
          const O = d !== -1 ? d : (
            // @ts-ignore
            t.tags.length - 1
          );
          typeof ((T = t.tags[O]) == null ? void 0 : T.operations) > "u" && (t.tags[O].operations = []), t.tags[O].operations.push(i);
        });
    });
  });
  const r = {
    ...t,
    webhooks: s
  };
  return C(r);
}, C = (t) => {
  var s;
  return {
    ...t,
    tags: (s = t.tags) == null ? void 0 : s.filter((r) => {
      var n;
      return ((n = r.operations) == null ? void 0 : n.length) > 0;
    })
  };
}, S = (t) => {
  if (typeof t == "string")
    try {
      return JSON.parse(t);
    } catch (s) {
      if (t.length > 0 && ["{", "["].includes(t[0]))
        throw s;
      return I.load(t);
    }
  return t;
}, N = x, u = (t) => {
  var o, i, a, c;
  const s = ((o = t.info) == null ? void 0 : o.title) !== void 0, r = ((i = t.info) == null ? void 0 : i.description) !== void 0, n = ((a = t.tags) == null ? void 0 : a.length) ?? 0, f = Object.keys(t.paths).reduce(
    (p, g) => p + Object.keys(t.paths[g]).length,
    0
  ), e = Object.keys(((c = t == null ? void 0 : t.components) == null ? void 0 : c.schemas) ?? {}).length ?? 0;
  return {
    hasTitle: s,
    hasDescription: r,
    numberOfTags: n,
    numberOfOperations: f,
    numberOfModels: e
  };
};
export {
  M as analyze,
  x as parse,
  S as parseJsonOrYaml,
  N as parseSwaggerFile,
  u as preflight
};
